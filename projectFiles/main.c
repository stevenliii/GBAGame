#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"

#include "gamebackground.h"
#include "gameoverbackground.h"
#include "gamewonbackground.h"
#include "startbackground.h"
#include "playerimage.h"
#include <string.h>
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT= MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  struct Player player;
  player.col = 10;
  player.row = 80;
  player.lives = '3';

  struct Obstacle obstacle1;
  obstacle1.col = 115;
  obstacle1.row = 75;
  obstacle1.xdirection = (player.col - obstacle1.col) / abs(player.col - obstacle1.col);
  obstacle1.ydirection = (player.row - obstacle1.row) / abs(player.row - obstacle1.row);


  struct Goal goal;
  goal.col = 220;
  goal.row = 60;
  goal.width = 20;
  goal.height = 40;

  struct Player playerStates[15];
  for (int i = 0; i < 15; i++) {
    playerStates[i].col = player.col;
    playerStates[i].row = player.row;
  }

  static int frameCounter = 0;
  static int latentCounter = 1;

  drawFullScreenImageDMA(startbackground);

  drawFullScreenImageDMA(startbackground);
  
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
      state = START;
      player.col = 10;
      player.row = 80;
      player.lives = '3';
      for (int i = 0; i < 15; i++) {
        playerStates[i].col = player.col;
        playerStates[i].row = player.row;
      }
      frameCounter = 0;
      latentCounter = 1;
      obstacle1.col = 115;
      obstacle1.row = 75;
        if (playerStates[latentCounter].col != obstacle1.col) {
          obstacle1.xdirection = (playerStates[latentCounter].col - obstacle1.col) / abs(playerStates[latentCounter].col - obstacle1.col);
        } else {
          obstacle1.xdirection = 0;
        }
        if (playerStates[latentCounter].row != obstacle1.row) {
          obstacle1.ydirection = (playerStates[latentCounter].row - obstacle1.row) / abs(playerStates[latentCounter].row - obstacle1.row);
        } else {
          obstacle1.ydirection = 0;
        }
      drawFullScreenImageDMA(startbackground);
    }



    switch (state) {
      case START:

        if (KEY_DOWN(BUTTON_START, currentButtons)) {
          drawFullScreenImageDMA(gamebackground);
          state = PLAY;
        } else {
          char *str1 = "Welcome to World's Easiest Game";
          char *str2 = "Press Enter to Start";
          drawString(60, 30, str1, BLACK);
          drawString(100, 60, str2, BLACK);
        }
        // state = ?
        break;
      case PLAY:

        if (obstacle1.row > 160 - 10 || obstacle1.row < 0) {
          obstacle1.ydirection *= -1;
        }
        if (obstacle1.col > 240 - 10 || obstacle1.col < 0) {
          obstacle1.xdirection *= -1;
        }
        
        waitForVBlank();

        drawRectDMA(60, 220, 20, 40, GREEN);
        drawRectDMA(20, 0, 240, 3, BLACK);

        char *livesText = "Lives:";
        char livesNumber = player.lives;
        drawString(6, 10, livesText, BLACK);

        undrawImageDMA(6, 50, 10, 10, gamebackground);
        drawChar(6, 50, livesNumber, BLACK);


        drawImageDMA(player.row, player.col, 10, 10, playerimage);


        undrawImageDMA(obstacle1.row, obstacle1.col, 10, 10, gamebackground);
        if (playerStates[latentCounter].col != obstacle1.col) {
          obstacle1.xdirection = (playerStates[latentCounter].col - obstacle1.col) / abs(playerStates[latentCounter].col - obstacle1.col);
        } else {
          obstacle1.xdirection = 0;
        }
        if (playerStates[latentCounter].row != obstacle1.row) {
          obstacle1.ydirection = (playerStates[latentCounter].row - obstacle1.row) / abs(playerStates[latentCounter].row - obstacle1.row);
        } else {
          obstacle1.ydirection = 0;
        }
        // if (player.col != obstacle1.col) {
        //   obstacle1.xdirection = (player.col - obstacle1.col) / abs(player.col - obstacle1.col);
        // } else {
        //   obstacle1.xdirection = 0;
        // }
        // if (player.row != obstacle1.row) {
        //   obstacle1.ydirection = (player.row - obstacle1.row) / abs(player.row - obstacle1.row);
        // } else {
        //   obstacle1.ydirection = 0;
        // }
        obstacle1.row += obstacle1.ydirection;
        obstacle1.col += obstacle1.xdirection;
        drawRectDMA(obstacle1.row, obstacle1.col, 10, 10, RED);

        if (!(KEY_DOWN(BUTTON_UP, currentButtons) && KEY_DOWN(BUTTON_DOWN, currentButtons))){
          if (KEY_DOWN(BUTTON_UP, currentButtons) && player.row > 24) {
            undrawImageDMA(player.row, player.col, 10, 10, gamebackground);
            //player.row -= 2;
            player.row--;
            drawImageDMA(player.row, player.col, 10, 10, playerimage);
          } 
          if (KEY_DOWN(BUTTON_DOWN, currentButtons) && player.row < 160 - 10) {
            undrawImageDMA(player.row, player.col, 10, 10, gamebackground);
            //player.row += 2;
            player.row++;
            drawImageDMA(player.row, player.col, 10, 10, playerimage);
          }
        }
        if (!(KEY_DOWN(BUTTON_LEFT, currentButtons) && KEY_DOWN(BUTTON_RIGHT, currentButtons))){
          if (KEY_DOWN(BUTTON_LEFT, currentButtons) && player.col > 0) {
            undrawImageDMA(player.row, player.col, 10, 10, gamebackground);
            //player.col -= 2;
            player.col--;
            drawImageDMA(player.row, player.col, 10, 10, playerimage);
          } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons)&& player.col < 240 - 10) {
            undrawImageDMA(player.row, player.col, 10, 10, gamebackground);
            //player.col += 2;
            player.col++;
            drawImageDMA(player.row, player.col, 10, 10, playerimage);
          }
        }

        struct Player currPlayerState;
        currPlayerState.col = player.col;
        currPlayerState.row = player.row;
        playerStates[frameCounter] = currPlayerState;


        if (abs(player.row - obstacle1.row) < 10 && abs(player.col - obstacle1.col) < 10) {
          undrawImageDMA(player.row, player.col, 10, 10, gamebackground);
          player.col = 10;
          player.row = 80;
          player.lives--;
          drawImageDMA(player.row, player.col, 10, 10, playerimage);
          undrawImageDMA(obstacle1.row, obstacle1.col, 10, 10, gamebackground);
          obstacle1.col = 115;
          obstacle1.row = 75;
          if (playerStates[latentCounter].col != obstacle1.col) {
              obstacle1.xdirection = (playerStates[latentCounter].col - obstacle1.col) / abs(playerStates[latentCounter].col - obstacle1.col);
            } else {
              obstacle1.xdirection = 0;
            }
            if (playerStates[latentCounter].row != obstacle1.row) {
              obstacle1.ydirection = (playerStates[latentCounter].row - obstacle1.row) / abs(playerStates[latentCounter].row - obstacle1.row);
            } else {
              obstacle1.ydirection = 0;
            }
          drawRectDMA(obstacle1.row, obstacle1.col, 10, 10, RED);
        }
        if (((player.row > goal.row && player.row - goal.row < goal.height) || (player.row < goal.row && goal.row - player.row < 10)) && (goal.col - player.col < 10)) {
          state = WIN;
          drawFullScreenImageDMA(gamewonbackground);
        }

        if (player.lives <= '0') {
          state = LOSE;
          drawFullScreenImageDMA(gameoverbackground);
        }

        // state = ?
        break;
      case WIN:
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
          player.col = 10;
          player.row = 80;
          player.lives = '3';
          for (int i = 0; i < 15; i++) {
            playerStates[i].col = player.col;
            playerStates[i].row = player.row;
          }
          frameCounter = 0;
          latentCounter = 1;
          obstacle1.col = 115;
          obstacle1.row = 75;
            if (playerStates[latentCounter].col != obstacle1.col) {
              obstacle1.xdirection = (playerStates[latentCounter].col - obstacle1.col) / abs(playerStates[latentCounter].col - obstacle1.col);
            } else {
              obstacle1.xdirection = 0;
            }
            if (playerStates[latentCounter].row != obstacle1.row) {
              obstacle1.ydirection = (playerStates[latentCounter].row - obstacle1.row) / abs(playerStates[latentCounter].row - obstacle1.row);
            } else {
              obstacle1.ydirection = 0;
            }
          drawFullScreenImageDMA(startbackground);
        } else {
          char *str2 = "Press Delete to Play Again";
          drawString(100, 40, str2, GREEN);
        }
        
        // state = ?
        break;
      case LOSE:
        if (KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
          player.col = 10;
          player.row = 80;
          player.lives = '3';
          for (int i = 0; i < 15; i++) {
            playerStates[i].col = player.col;
            playerStates[i].row = player.row;
          }
          frameCounter = 0;
          latentCounter = 1;
          obstacle1.col = 115;
          obstacle1.row = 75;
            if (playerStates[latentCounter].col != obstacle1.col) {
              obstacle1.xdirection = (playerStates[latentCounter].col - obstacle1.col) / abs(playerStates[latentCounter].col - obstacle1.col);
            } else {
              obstacle1.xdirection = 0;
            }
            if (playerStates[latentCounter].row != obstacle1.row) {
              obstacle1.ydirection = (playerStates[latentCounter].row - obstacle1.row) / abs(playerStates[latentCounter].row - obstacle1.row);
            } else {
              obstacle1.ydirection = 0;
            }
          drawFullScreenImageDMA(startbackground);
        } else {
          char *str2 = "Press Delete to Try Again";
          drawString(100, 40, str2, RED);
        }
        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
    frameCounter++;
    if (frameCounter >= 15) {
      frameCounter = 0;
    }
    latentCounter++;
    if (latentCounter >= 15) {
      latentCounter = 0;
    }
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
